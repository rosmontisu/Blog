---
title: '[UE5/Part2] Ex2. UStaticMesh & Draw Call'
published: 2026-02-27
description: '동일한 UStaticMesh 컴포넌트를 월드에 다수 배치할 때 발생하는 시스템 부하의 원인을 메모리와 연산 관점에서 알아보자'
image: ''
tags: [Unreal Engine, C++, Opt.]
category: 'Unreal Engine'
draft: false 
lang: 'ko'
---

언리얼 엔진 C++ 개발 중 동일한 `UStaticMesh`를 사용하는 컴포넌트(예: 분수대, 총알 등)를 월드에 수십, 수백 개 배치할 때 발생하는 시스템 부하의 원인에 대해 찾아보고 정리해보았다.

흔히 직관적으로 "화면에 그려지는 개수가 많아지니 데이터가 복사되어 메모리 부하가 클 것"이라고 오해하지만, 실제 게임 엔진의 병목 지점은 완전히 다른 곳에 있다.

## 1. 메모리 관점: 복사가 아닌 '참조' (Flyweight Pattern)

월드에 동일한 액터를 100개 배치한다고 해서 형태를 구성하는 메시 데이터(버텍스, 인덱스, UV 등)가 메모리에 100번 복사되지 않는다. 현대 게임 엔진은 플라이웨이트 패턴(Flyweight Pattern)을 기반으로 리소스를 관리한다.

* **시스템 RAM (CPU 영역):** 엔진 초기화 시 원본 `UStaticMesh` 데이터는 단 한 번만 로드된다. 각 컴포넌트(`UStaticMeshComponent`)는 이 원본 데이터의 메모리 주소를 가리키는 포인터만을 소유한다.
* **VRAM (GPU 영역):** 렌더링을 위해 그래픽 카드로 데이터가 넘어갈 때도 마찬가지다. 메시의 버텍스 정보는 GPU 메모리의 버텍스 버퍼(Vertex Buffer)에 딱 한 번만 올라간다.

결과적으로 인스턴스가 아무리 늘어나도 동일한 데이터를 재참조할 뿐이므로, 데이터 '복사'로 인한 메모리 오버헤드는 0에 가깝다.

## 2. 렌더링 관점: 진짜 부하의 원인은 '드로우 콜(Draw Call)'

메모리 복사 부하가 없다면 왜 객체를 많이 그릴수록 프레임이 떨어질까? 부하의 핵심은 데이터의 크기가 아니라 **명령의 횟수**에 있다.

CPU가 GPU에게 "이 메시를 그려라"라고 명령을 내리는 과정을 **드로우 콜(Draw Call)** 이라고 한다.

`CPU -> GPU`
1. CPU가 렌더링할 객체의 월드 트랜스폼(위치, 회전, 스케일)을 계산한다.
2. GPU에게 렌더링 상태 변경(머티리얼, 쉐이더 설정 등)을 지시한다.
3. GPU에게 그리기(Draw) 명령을 보낸다.

이 과정에서 CPU와 GPU 사이의 통신 비용(Context Switching)이 발생한다. 화면에 그릴 객체가 수백 개로 늘어나면 이 통신 횟수 자체가 기하급수적으로 증가한다. 결국 CPU는 명령을 보내느라 과부하가 걸리고, GPU는 이전 명령을 처리하고 다음 명령을 기다리며 노는(Idle) **병목 현상**이 발생한다. 부하는 그리는 행위(연산) 그 자체와 명령 하달 과정에서 발생한다.

## 3. 최적화 기법: 하드웨어 인스턴싱 (Hardware Instancing)

엔진은 드로우 콜 병목을 해결하기 위해 하드웨어 인스턴싱이라는 최적화 기법을 사용한다.

* **기존 방식:** 100개의 분수대를 그리기 위해 CPU가 GPU에게 100번의 드로우 콜을 보냄.
* **인스턴싱 방식:** 버텍스 정보는 1번만 참조하되, 100개의 분수대 `위치 정보(Transform Matrix)`를 배열로 묶어 GPU에 전달. CPU는 "이 1개의 버텍스 데이터를 사용해서, 여기 전달한 100개의 위치에 한 번에 그려라"라는 `단일 명령(1 Draw Call)`을 내림.

이를 통해 CPU의 오버헤드를 극적으로 줄이고, GPU의 연산 유닛(ALU)을 효율적으로 점유하여 렌더링을 수행할 수 있다.

## 4. C++ 생성자 코드와의 연관성

```cpp
// 컴포넌트 생성 및 에셋 참조
Body = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Body"));
static ConstructorHelpers::FObjectFinder<UStaticMesh> BodyMeshRef(TEXT("경로"));
if (BodyMeshRef.Succeeded())
{
	Body->SetStaticMesh(BodyMeshRef.Object);
}

```

위의 C++ 코드는 단순히 컴포넌트를 만들고 에셋을 끼워 넣는 과정처럼 보이지만, 엔진 구조적으로는 **CDO(Class Default Object)** 를 구성하는 단계다.

런타임에 동적으로 에셋을 복사해오는 것이 아니라, 엔진 초기화 단계에서 `ConstructorHelpers`를 통해 에셋을 단 한 번 메모리에 적재해 CDO를 완성한다. 이후 게임 내에서 스폰되는 모든 해당 클래스의 인스턴스들은 이 CDO에 적재된 에셋의 주소값만을 안전하게 참조(Reference)하도록 설계되어 있다.

## 정리

1. 메시는 복사되지 않고 한 번만 로드되어 **참조**된다. (메모리 최적화)
2. 렌더링 부하의 본질은 ~데이터 복사~ X, **반복 연산**과 **드로우 콜 오버헤드**다.
3. 엔진은 이를 하드웨어 인스턴싱 등을 통해 병합 처리하여 부하를 제어한다.